# ğŸ›¡ï¸ MCP Directory â€“ Windsurf IDE Rules

## ğŸ§± Project Architecture

- This is a **Model Context Protocol (MCP) directory** app using:
  - Supabase MCP (auth, DB, edge functions)
  - Netlify MCP (frontend hosting, edge deploy)
  - Firecrawl MCP (external crawling & data ingestion)

- The app consists of 4 main layers:
  1. **Frontend (React + Tailwind + Shadcn UI)**
  2. **Edge Functions (Supabase)**
  3. **Database Schema (Postgres)**
  4. **MCP Agents + Crawl Logic**

---

## ğŸ“ Naming Conventions

- File names: kebab-case (e.g., `server-card.tsx`, `cli-generator-tool.md`)
- Function names: camelCase for JavaScript, snake_case for SQL
- API endpoints:
  - `/servers/search`
  - `/servers/:id`
  - `/servers/health`
  - `/cli/generate`
  - `/crawl/start`

---

## ğŸ§  Prompt Strategy

- Use **modular prompts** for each feature or file
- Follow the 3-part format:
  1. ğŸ¯ **Goal** â€“ high-level intent
  2. ğŸ§  **Task Breakdown** â€“ detailed implementation steps
  3. âœ… **Deliverables** â€“ what the output must contain

---

## ğŸ”„ Function Standards

- Edge functions must:
  - Be RESTful and stateless
  - Validate input parameters
  - Return typed JSON
  - Use Supabase client and secure env vars
  - Enforce RLS via policy (anonymous read allowed for public endpoints)

- All GETs must support:
  - Pagination (limit, offset) if data > 50
  - Caching headers where safe

---

## ğŸ–¥ï¸ UI Standards

- Use `Shadcn UI` components and `TailwindCSS`
- Ensure:
  - Mobile responsiveness
  - Accessible components (WCAG 2.1)
  - Visual cues for server health and install method
  - Keyboard navigation support

---

## ğŸ—‚ï¸ Folder Structure
/components
	â€¢	ServerCard.tsx
	â€¢	CLIGenerator.tsx

/pages
	â€¢	Discover.tsx
	â€¢	ServerDetail.tsx

/functions
	â€¢	crawl-start.ts
	â€¢	servers-search.ts
	â€¢	servers-id.ts
	â€¢	servers-health.ts
	â€¢	cli-generate.ts

/prompts
	â€¢	*.md (prompt definition files)

/schemas
	â€¢	servers.sql
	â€¢	server_status.sql

---

## ğŸ” Supabase RLS Rules

- Public anonymous users can:
  - Read from `servers`, `server_status`, `compatibility`, `metrics`
- Only internal edge functions can:
  - Insert/update into `servers`, `server_status`, `metrics`
  - Write via service role or elevated token

---

## ğŸ“¬ API Error Handling

- Always return structured errors:
```json
{
  "error": true,
  "message": "Missing server ID",
  "code": 400
}
	â€¢	Use HTTP status codes:
	â€¢	200 OK
	â€¢	400 Bad Request
	â€¢	404 Not Found
	â€¢	500 Internal Error


â¸»

âœ… Deployment & Build Rules
	â€¢	Frontend is deployed to Netlify from /frontend/dist
	â€¢	Use netlify.toml to define build and function routes
	â€¢	Edge functions bundled using Supabase MCP
	â€¢	Supabase keys and GitHub tokens stored securely in Netlify env vars

â¸»

ğŸ§ª Testing Requirements
	â€¢	Every page/component must include:
	â€¢	Loading state
	â€¢	Empty state
	â€¢	Error state
	â€¢	Edge functions must:
	â€¢	Be testable via Postman or CLI script
	â€¢	Return mock-friendly outputs

â¸»

ğŸŒ Internationalization
	â€¢	Use English as default UI language
	â€¢	Plan for i18n-ready components with message keys
	â€¢	Add language field to server records when relevant

â¸»

ğŸ§  AI Agents (Optional)
	â€¢	MCP-aware LLMs like Claude/DeepSeek may be added for:
	â€¢	Install walkthroughs
	â€¢	Health diagnostics
	â€¢	Compatibility checks

â¸»

âœ… Always Do
	â€¢	Break large features into smaller prompts
	â€¢	Use code comments in all functions
	â€¢	Define types/interfaces in a separate types/ folder
	â€¢	Link prompts to actual output files clearly

ğŸš« Never Do
	â€¢	Mix inline type definitions
	â€¢	Hardcode server IDs or URLs
	â€¢	Block anonymous reads on public endpoints
	â€¢	Rely on client-side only for install command logic

â¸»
- Do not give me code unless I explicitly ask for it.
- Guide me in problem-solving instead of providing direct answers.
- When I ask about programming concepts (e.g., "What is a hook?"), give me a direct and clear explanation.
- Break problems into smaller, manageable steps and help me think through them.
- Ask leading questions and provide hints instead of just telling me the answer.
- Encourage me to debug independently before offering suggestions.
- Refer me to relevant documentation instead of providing solutions.
- Encourage modular thinkingâ€”breaking problems into reusable components.
- Remind me to reflect on what I learned after solving an issue.
- If I explicitly ask for code (e.g., "Give me the code"), then you can provide it.

- Encourage me to read and understand error messages instead of just fixing the issue for me.
- Help me identify patterns in my mistakes so I can improve my debugging skills.
- Suggest different approaches instead of leading me to one specific solution.
- Guide me toward using console.log(), browser dev tools, and other debugging techniques.
- Help me understand how to search effectively (e.g., Googling error messages or checking documentation